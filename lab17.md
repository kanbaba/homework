# 排序算法 

## 排序
#### 冒泡排序  
![](https://ws1.sinaimg.cn/large/007kRF1Jgy1fxk941h3pyg307s06ldhe.jpg)  

这张动态图简洁的表示了什么是冒泡排序。  

冒泡排序是龟速三巨头之首，核心是“冒泡”，通过每个元素与其他剩余元素的比较，依次把最小的元素冒出来，达到排序的目的。  

冒牌排序运用两个for循环实现了整个排序过程。  

第一个for循环：控制排序轮数。  
第二个for循环：控制每一轮比较的每一个步骤。  

代码：（懒得一个符号一个符号的敲，附上一个知乎大佬的[帖子链接][1]）  

#### 鸡尾酒排序  

鸡尾酒排序就是对冒泡排序的一个改进。  
它与冒牌排序之间的区别在于冒泡排序只从前面向后一个个比交，而鸡尾酒排序可以还会从后往前一个个比较。  
鸡尾酒排序会得到比冒泡排序好一点点的性能，假如是一个随机的数串，鸡尾酒排序可能比冒泡排序好不到哪里去。  

加一张动图：
[鸡尾酒排序动图](https://baike.baidu.com/pic/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/7515196/0/79f0f736afc3793166033f22eac4b74543a91155)  

看了上面那个动图之后，那个红色的条条从左到右，从右到左。而在冒泡排序中，这个条条只会从左到右。  

代码的话，还是给个链接（[鸡尾酒排序算法解析与代码](https://zhuanlan.zhihu.com/p/42870222)）  

#### 选择排序  
现在轮到龟速三巨头第二的选择排序登场了。  
选择排序其实个人感觉和冒牌排序差不多。  
冒牌排序是比大小，比一次数字换一次位置。选择排序是比大小，一直比，把需要提到前面的数字记录下来，比完一轮，到最后再换位置，一轮只换一次位置。   
给张形象的动图： 
![](https://ws1.sinaimg.cn/large/007kRF1Jgy1fxk9v4yoxpg30800800st.jpg)

和冒牌排序的比一下你就会发现，冒泡排序的点是一点点的滑到中间的，选择排序的是直接消失跳到中间。  

#### 插入排序  
先把龟速三巨头最后一个——插入排序说了吧。  

插入排序就是在插入啊.....   

插入排序首先要把第一个元素当作排序后的一个数组。假如第二个元素大于第一个，那么就保持不动（从小到大），假如第二个元素小，就移到前面去。这样两个元素就再次形成了一个有序数组。以此类推，无限循环。  
给张动态图：![](https://ws1.sinaimg.cn/large/007kRF1Jgy1fxka5bbgzyg307s06lq5y.jpg)  

看图中的点，是不是每个元素都找到了自己应该在的位置后逐渐合在一起形成了一条线。这就是他们的插入。   

代码：  

    void insert_sort(int *array,unsigned int n)
    {
        int i,j;
        int temp;

        for(i=1;i<n;i++)
        {
            temp=*(array+i);
            for(j=i;j>0&&*(array+j-1)>temp;j--)
            {
                 *(array+j)=*(array+j-1);
            }
            *(array+j)=temp;
        }
    }


#### 快速排序  
讲完了龟速三巨头，我们讲点快的————快速排序。  

快速排序是一个什么样的算法呢？很简单的，是一个听起来就很快的算法，也确实快。  

快速排序利用了递归的算法，二分的思想。  
快速排序就是把一个元素作为基准，把比它大的，比它小的，分成两个序列。在两个序列中做相同操作，直到完成排序。  

举个栗子：
让我们来假设一下，有这样一个序列：  
3 1 4 5 2  
我们怎么让它来排序呢？  
首先，我们把2放到中间，把比它大的3 4 5分到后面的序列，把比它小的1放到前面的序列.3 4 5继续执行这个操作，4为基准，3和5就分开了。

如果对于这个过程大家理解不了， 那我用一下知乎大佬的图片吧：  
![](https://ws1.sinaimg.cn/large/007kRF1Jgy1fxkalfhq8fj30o00d6my8.jpg)  

总的来说，快速排序只有三步：  
1.在这个序列中取一个数a（这里我们取序列最后的一个元素值作为a）  
2.将序列分为比a大的部分和比a小的部分以及元素a  
3.循环进行1.2两个步骤直到序列中的元素个数为1  

动图一张：  
![](https://ws1.sinaimg.cn/large/007kRF1Jgy1fxkanlx2ryg307s05ytay.jpg)    

（看得懂吗？看不懂没关系，看懂就好了。要是实在看不懂也没事，反正我看懂了）

代码：  

    #include <stdio.h>

    int Partition(int *a, int begin, int end)
    {
	    int f = a[end];	//获得中间值 
	    int num_min_f = begin-1;	//小于中间值的数目，数组的下标从0计算，所以这里取-1
	    int i; 
	    for(i = begin; i<=end; i++)
        {
		    if(a[i] < f)
            {
			    //捕捉到一个小于f的值
			    num_min_f++;
			    //交换 
			    int temp;
			    temp = a[i];
			    a[i] = a[num_min_f];
			    a[num_min_f] = temp;
		    }
	    } 

	    //这样前num_min_f个树都比f小[0,num_min_f-1]
	    num_min_f++;
	    //a[num_min_f]的值设为中间值 
	    a[end] = a[num_min_f];
	    a[num_min_f] = f;
	    //坐标小于num_min_f的值小于等于中间值，大于num_min_f的值大于中间值 
	    return num_min_f;
    }
    //快速排序 
    void quickSort(int *a, int begin, int end)
    {
	    if(begin <= end)
        {
		    //将原序列分为比a小的序列，a，比a大的序列 
		    int mid = Partition(a, begin, end);	//获得中间值a的位置 
		    quickSort(a, begin, mid-1);	//前一半
		    quickSort(a, mid+1, end);  //后一半 
	    }
    }

    int main()
    {
	    int a[10] = {2, 5, 4, 3, 1, 15, 3, 35, 21, 12};
	    quickSort(a, 0, 9);
	    int i;
	    for(i = 0; i < 10; i++)
        {
	    	printf("%d ", a[i]);
	    }
	    return 0;
    } 

比较复杂，看不懂我说的也可以去看[知乎大佬——超爱学习的帖子](https://zhuanlan.zhihu.com/p/46238008
)反正我也是看了他的才会这个。  

#### 梳排序  
我觉得我还可以说个梳排序。  
梳排序是改良自冒泡排序和插入排序的一种算法。

简单的来说，冒泡排序是相邻两项比较最后得到最小的往前冒泡。而梳排序不是相邻两项，相比较的两项之间的项数逐渐减小，直到减为1，之后减为1的时候相当于一轮冒泡排序。  

经过发明者精密的计算，每次间隔递减1.3是最合理的。1.3叫做递减率。 
假如不明白什么是递减率，我给个[梳排序递减率](https://blog.csdn.net/u010647471/article/details/50170825)的链接，大家自己看，绝对能懂。  

动图在你看了递减率后特别容易明白，也会加深你对梳排序的理解：  
![]()



[1]:https://www.zhihu.com/question/20063815/answer/307255236