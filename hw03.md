Write out variables x, y and z in binary code  


1) int8_t x = 67; int8_t y = -7; int8_t z = y - x;  
x = 01000011，y = 11111001，z = 10110110  

2) int8_t x = 0xd3;  
x ：overflow  

3) uint8_t x = 0xd3;  
x = 11010011  

4) int8_t x = 127; int8_t y = -7; int8_t z = y – x;  
x = 01111111，y = 11111001，z ：overflow  

5) float x = 1.125;  
x = 0 10000000 00100000000000000000000  

6) float x = 23.0;  
x = 0 10000011 01110000000000000000000  

7) float x = 0.45;  
x ：精度误差  



使用维基百科，解释以下概念。  

1)Method of complements  
在数学和计算中，补语方法是一种仅使用正数加法从另一个数中减去一个数的技术。这种方法常用于机械计算器，仍用于现代计算机。  

2)Byte  
字节是数字信息的单位，通常由8 位组成，表示二进制数。  

3)Integer (computer science)  
在计算机科学中，一个整数是一个基准的积分数据类型，一个数据类型，它表示一些数学整数范围。  

4)Floating point  
在计算中，浮点运算（FP）是使用实数的公式表示作为近似的算术，以支持范围和精度之间的折衷。  

仔细阅读” Method of complements”的内容，你将注意到nines‘ complement in
the decimal 和 ones’ complement in binary 等概念.  

1)请证明：二进制的负数（two‘s complement of X）等于 X 的 ones’
complement ＋ 1（即，X每位求反加1）  

在二进制的每个字节中，代表X与-X的二进制数之和为100000000(0和-128除外)。  
因为100000000=11111111+1  
而当11111111-代表X的二进制数时，得到的二进制数恰好为X的补码。  
所以X的补码+1 所得到的二进制数就恰好为-X的二进制数。  


2)Int8_t x = - 017; 请用8进制描述变量 x。在c中017即(017)8 阅读维基百科” Two‘s complement”的内容，特别是Sign extension小节内容。

用二进制数描述变量x为11101111，转化为8进制则是357

1)C程序：int8_t x = -0x1f; int y = x; 请用16进制描述变量 x 和 y，并说明 int
y = x 的计算过程。  

x的二进制数为11100001，它的16进制数是E1。  
y的二进制数为111111111111111111100001，它的16进制数是FFFFE1。  

int为4个字节，即32比特，因为x所代表的数为负数，所以可以在前面加上24位1。  

2)请用数学证明，为什么可以这么计算。  
  
-0x1f=-31，31的2进制表示为11111。  
因为int有32比特，所以即为00000000000000000000000000011111  
反码为11111111111111111111111111100000  
加1得到补码11111111111111111111111111100001  

所以我们可以知道，如果是负数，左边就补齐1，正数左边就补齐0.  
因此，计算机可以通过最左端的二进制数字判断数字的正负，这也是二进制的优越性之一。


阅读维基百科” Floating point”的内容，
1) NaN 是什么？  
标准指定的NaN的表示具有一些未指定的位，可用于编码错误的类型或来源; 但是没有该编码的标准。